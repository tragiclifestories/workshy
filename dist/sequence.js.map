{"version":3,"sources":["sequence.js"],"names":[],"mappings":";;;;;;;;;;;;oBAAoB,QAAQ;;;;IAEtB,QAAQ;AACC,aADT,QAAQ,CACE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE;8BAD7B,QAAQ;;AAEN,YAAI,CAAC,UAAU,GAAG,GAAG,CAAC;AACtB,YAAI,CAAC,KAAK,GAAG,IAAI,CAAC;AAClB,YAAI,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KACvC;;iBALC,QAAQ;aAOT,MAAM,CAAC,QAAQ;eAAC,iBAAG;AAChB,mBAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;SAClD;;;eAEG,cAAC,CAAC,EAAE;AACJ,mBAAO,IAAI,QAAQ,oBAAU,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;SAC3C;;;eAEE,aAAC,EAAE,EAAE;AACJ,gBAAI,MAAM,2BAAG,SAAT,MAAM,CAAc,EAAE,EAAE,QAAQ;oGACvB,GAAG;;;;;;;;;wCAAI,QAAQ;;;;;;;;AAAf,+BAAG;;mCAAoB,EAAE,CAAC,GAAG,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBADvC,MAAM;aAET,CAAA,CAAC;AACF,mBAAO,IAAI,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;SAC3C;;;eAEK,gBAAC,EAAE,EAAE;AACP,gBAAI,SAAS,2BAAG,SAAZ,SAAS,CAAc,EAAE,EAAE,QAAQ;yGAC1B,GAAG;;;;;;;;;yCAAI,QAAQ;;;;;;;;AAAf,+BAAG;;iCACJ,EAAE,CAAC,GAAG,CAAC;;;;;;mCAAQ,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAF1B,SAAS;aAIZ,CAAA,CAAC;;AAEF,mBAAO,IAAI,QAAQ,CAAC,SAAS,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;SAC9C;;;eAEM,mBAAG;AACN,gBAAI,MAAM,GAAG,EAAE,CAAC;;;;;;AAChB,sCAAgB,IAAI,mIAAG;wBAAd,GAAG;;AACJ,0BAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACpB;;;;;;;;;;;;;;;;AACL,mBAAO,MAAM,CAAC;SACjB;;;eAEK,gBAAC,EAAE,EAAE,GAAG,EAAE;AACZ,gBAAI,CAAC,GAAG,CAAC,CAAC;;;;;;AACV,sCAAgB,IAAI,mIAAE;wBAAb,GAAG;;AACR,wBAAI,EAAC,CAAC,EAAE,IAAI,OAAO,GAAG,KAAK,WAAW,EAAE,GAAG,GAAG,GAAG,CAAC,KAC7C,GAAG,GAAG,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;iBAC3B;;;;;;;;;;;;;;;;AAED,mBAAO,GAAG,CAAC;SACd;;;WAhDC,QAAQ;;;qBAmDC,QAAQ","file":"sequence.js","sourcesContent":["import takeGen from './take';\n\nclass Sequence {\n    constructor(gen, args, parent) {\n        this._generator = gen;\n        this._args = args;\n        if (parent) this._args.push(parent);\n    }\n\n    [Symbol.iterator]() {\n        return this._generator.apply(this, this._args);\n    }\n\n    take(n) {\n        return new Sequence(takeGen, [n], this);\n    }\n\n    map(fn) {\n        let mapGen = function* (fn, iterable) {\n            for (let val of iterable) yield fn(val);\n        };\n        return new Sequence(mapGen, [fn], this);\n    }\n\n    filter(fn) {\n        let filterGen = function* (fn, iterable) {\n            for (let val of iterable) {\n                if (fn(val)) yield val; \n            }\n        };\n\n        return new Sequence(filterGen, [fn], this);\n    }\n\n    toArray() {\n        let result = [];\n        for (let val of this)  {\n                result.push(val);\n            }\n        return result;\n    }\n\n    reduce(fn, acc) {\n        let i = 0;\n        for (let val of this) {\n            if (!i++ && typeof acc === 'undefined') acc = val;\n            else acc = fn(acc, val);\n        }\n\n        return acc;\n    }\n}\n\nexport default Sequence;"],"sourceRoot":"/source/"}